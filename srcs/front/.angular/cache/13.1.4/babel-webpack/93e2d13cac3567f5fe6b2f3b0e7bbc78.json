{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { LOCALE_ID, Injectable, Inject, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { formatDate, CommonModule } from '@angular/common';\n\nfunction CountdownComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"innerHTML\", ctx_r0.i.text, i0.ɵɵsanitizeHtml);\n  }\n}\n\nfunction CountdownComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nvar CountdownStatus = /*#__PURE__*/(() => {\n  (function (CountdownStatus) {\n    CountdownStatus[CountdownStatus[\"ing\"] = 0] = \"ing\";\n    CountdownStatus[CountdownStatus[\"pause\"] = 1] = \"pause\";\n    CountdownStatus[CountdownStatus[\"stop\"] = 2] = \"stop\";\n    CountdownStatus[CountdownStatus[\"done\"] = 3] = \"done\";\n  })(CountdownStatus || (CountdownStatus = {}));\n\n  return CountdownStatus;\n})();\n// tslint:disable: no-inferrable-types\nlet CountdownGlobalConfig = /*#__PURE__*/(() => {\n  class CountdownGlobalConfig {\n    constructor(locale) {\n      this.locale = locale;\n      this.demand = false;\n      this.leftTime = 0;\n      this.format = 'HH:mm:ss';\n      this.timezone = '+0000';\n\n      this.formatDate = ({\n        date,\n        formatStr,\n        timezone\n      }) => {\n        return formatDate(new Date(date), formatStr, this.locale, timezone || this.timezone || '+0000');\n      };\n    }\n\n  }\n\n  CountdownGlobalConfig.ɵfac = function CountdownGlobalConfig_Factory(t) {\n    return new (t || CountdownGlobalConfig)(i0.ɵɵinject(LOCALE_ID));\n  };\n\n  CountdownGlobalConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CountdownGlobalConfig,\n    factory: CountdownGlobalConfig.ɵfac,\n    providedIn: 'root'\n  });\n  return CountdownGlobalConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CountdownTimer = /*#__PURE__*/(() => {\n  class CountdownTimer {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.fns = [];\n      this.commands = [];\n      this.nextTime = 0;\n      this.ing = false;\n    }\n\n    start() {\n      if (this.ing === true) {\n        return;\n      }\n\n      this.ing = true;\n      this.nextTime = +new Date();\n      this.ngZone.runOutsideAngular(() => {\n        this.process();\n      });\n    }\n\n    process() {\n      while (this.commands.length) {\n        this.commands.shift()();\n      }\n\n      let diff = +new Date() - this.nextTime;\n      const count = 1 + Math.floor(diff / 100);\n      diff = 100 - diff % 100;\n      this.nextTime += 100 * count;\n\n      for (let i = 0, len = this.fns.length; i < len; i += 2) {\n        let frequency = this.fns[i + 1]; // 100/s\n\n        if (0 === frequency) {\n          this.fns[i](count); // 1000/s\n        } else {\n          // 先把末位至0，再每次加2\n          frequency += 2 * count - 1;\n          const step = Math.floor(frequency / 20);\n\n          if (step > 0) {\n            this.fns[i](step);\n          } // 把末位还原成1\n\n\n          this.fns[i + 1] = frequency % 20 + 1;\n        }\n      }\n\n      if (!this.ing) {\n        return;\n      }\n\n      setTimeout(() => this.process(), diff);\n    }\n\n    add(fn, frequency) {\n      this.commands.push(() => {\n        this.fns.push(fn);\n        this.fns.push(frequency === 1000 ? 1 : 0);\n        this.ing = true;\n      });\n      return this;\n    }\n\n    remove(fn) {\n      this.commands.push(() => {\n        const i = this.fns.indexOf(fn);\n\n        if (i !== -1) {\n          this.fns.splice(i, 2);\n        }\n\n        this.ing = this.fns.length > 0;\n      });\n      return this;\n    }\n\n  }\n\n  CountdownTimer.ɵfac = function CountdownTimer_Factory(t) {\n    return new (t || CountdownTimer)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  CountdownTimer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CountdownTimer,\n    factory: CountdownTimer.ɵfac\n  });\n  return CountdownTimer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CountdownComponent = /*#__PURE__*/(() => {\n  class CountdownComponent {\n    constructor(locale, timer, defCog, cdr, ngZone) {\n      this.locale = locale;\n      this.timer = timer;\n      this.defCog = defCog;\n      this.cdr = cdr;\n      this.ngZone = ngZone;\n      this.frequency = 1000;\n      this._notify = {};\n      this.status = CountdownStatus.ing;\n      this.isDestroy = false;\n      this.i = {};\n      this.left = 0;\n      this.event = new EventEmitter();\n    }\n\n    set config(i) {\n      if (i.notify != null && !Array.isArray(i.notify) && i.notify > 0) {\n        i.notify = [i.notify];\n      }\n\n      this._config = i;\n    }\n\n    get config() {\n      return this._config;\n    }\n    /**\n     * Start countdown, you must manually call when `demand: false`\n     */\n\n\n    begin() {\n      this.status = CountdownStatus.ing;\n      this.callEvent('start');\n    }\n    /**\n     * Restart countdown\n     */\n\n\n    restart() {\n      if (this.status !== CountdownStatus.stop) {\n        this.destroy();\n      }\n\n      this.init();\n      this.callEvent('restart');\n    }\n    /**\n     * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover\n     */\n\n\n    stop() {\n      if (this.status === CountdownStatus.stop) {\n        return;\n      }\n\n      this.status = CountdownStatus.stop;\n      this.destroy();\n      this.callEvent('stop');\n    }\n    /**\n     * Pause countdown, you can use `resume` to recover again\n     */\n\n\n    pause() {\n      if (this.status === CountdownStatus.stop || this.status === CountdownStatus.pause) {\n        return;\n      }\n\n      this.status = CountdownStatus.pause;\n      this.callEvent('pause');\n    }\n    /**\n     * Resume countdown\n     */\n\n\n    resume() {\n      if (this.status === CountdownStatus.stop || this.status !== CountdownStatus.pause) {\n        return;\n      }\n\n      this.status = CountdownStatus.ing;\n      this.callEvent('resume');\n    }\n\n    callEvent(action) {\n      this.event.emit({\n        action,\n        left: this.left,\n        status: this.status,\n        text: this.i.text\n      });\n    }\n\n    init() {\n      const {\n        locale,\n        defCog\n      } = this;\n      const config = this.config = Object.assign(Object.assign(Object.assign({}, new CountdownGlobalConfig(locale)), defCog), this.config); // tslint:disable-next-line: no-bitwise\n\n      const frq = this.frequency = ~config.format.indexOf('S') ? 100 : 1000;\n      this.status = config.demand ? CountdownStatus.pause : CountdownStatus.ing;\n      this.getLeft(); // bind reflow to me\n\n      const _reflow = this.reflow;\n\n      this.reflow = (count = 0, force = false) => _reflow.apply(this, [count, force]);\n\n      if (Array.isArray(config.notify)) {\n        config.notify.forEach(time => {\n          if (time < 1) {\n            throw new Error(`The notify config must be a positive integer.`);\n          }\n\n          time = time * 1000;\n          time = time - time % frq;\n          this._notify[time] = true;\n        });\n      }\n\n      this.timer.add(this.reflow, frq).start();\n      this.reflow(0, true);\n    }\n\n    destroy() {\n      this.timer.remove(this.reflow);\n      return this;\n    }\n    /**\n     * 更新时钟\n     */\n\n\n    reflow(count = 0, force = false) {\n      if (this.isDestroy) {\n        return;\n      }\n\n      const {\n        status,\n        config,\n        _notify\n      } = this;\n\n      if (!force && status !== CountdownStatus.ing) {\n        return;\n      }\n\n      let value = this.left = this.left - this.frequency * count;\n\n      if (value < 1) {\n        value = 0;\n      }\n\n      this.i = {\n        value,\n        text: config.formatDate({\n          date: value,\n          formatStr: config.format,\n          timezone: config.timezone\n        })\n      };\n\n      if (typeof config.prettyText === 'function') {\n        this.i.text = config.prettyText(this.i.text);\n      }\n\n      this.cdr.detectChanges();\n\n      if (config.notify === 0 || _notify[value]) {\n        this.ngZone.run(() => {\n          this.callEvent('notify');\n        });\n      }\n\n      if (value === 0) {\n        this.ngZone.run(() => {\n          this.status = CountdownStatus.done;\n          this.destroy();\n          this.callEvent('done');\n        });\n      }\n    }\n    /**\n     * 获取倒计时剩余帧数\n     */\n\n\n    getLeft() {\n      const {\n        config,\n        frequency\n      } = this;\n      let left = config.leftTime * 1000;\n      const end = config.stopTime;\n\n      if (!left && end) {\n        left = end - new Date().getTime();\n      }\n\n      this.left = left - left % frequency;\n    }\n\n    ngOnInit() {\n      this.init();\n\n      if (!this.config.demand) {\n        this.begin();\n      }\n    }\n\n    ngOnDestroy() {\n      this.isDestroy = true;\n      this.destroy();\n    }\n\n    ngOnChanges(changes) {\n      if (!changes.config.firstChange) {\n        this.restart();\n      }\n    }\n\n  }\n\n  CountdownComponent.ɵfac = function CountdownComponent_Factory(t) {\n    return new (t || CountdownComponent)(i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(CountdownTimer), i0.ɵɵdirectiveInject(CountdownGlobalConfig), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  CountdownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CountdownComponent,\n    selectors: [[\"countdown\"]],\n    hostVars: 2,\n    hostBindings: function CountdownComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"count-down\", true);\n      }\n    },\n    inputs: {\n      config: \"config\",\n      render: \"render\"\n    },\n    outputs: {\n      event: \"event\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 5,\n    consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"innerHTML\"]],\n    template: function CountdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, CountdownComponent_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, CountdownComponent_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.render);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.render)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c0, ctx.i));\n      }\n    },\n    directives: [i3.NgIf, i3.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return CountdownComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CountdownModule = /*#__PURE__*/(() => {\n  class CountdownModule {}\n\n  CountdownModule.ɵfac = function CountdownModule_Factory(t) {\n    return new (t || CountdownModule)();\n  };\n\n  CountdownModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CountdownModule\n  });\n  CountdownModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [CountdownTimer],\n    imports: [[CommonModule]]\n  });\n  return CountdownModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CountdownComponent, CountdownGlobalConfig, CountdownModule, CountdownStatus, CountdownTimer }; //# sourceMappingURL=ngx-countdown.mjs.map","map":null,"metadata":{},"sourceType":"module"}